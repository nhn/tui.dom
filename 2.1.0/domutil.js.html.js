tui.util.defineNamespace("fedoc.content", {});
fedoc.content["domutil.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview DOM manipulation utility module\n * @author NHN Ent. FE Development team &lt;dl_javascript@nhnent.com>\n */\nimport util from 'code-snippet';\nimport * as domevent from './domevent';\n\nconst aps = Array.prototype.slice;\nconst trim = str => str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n\n/**\n * Setting element style\n * @param {(HTMLElement|SVGElement)} element - element to setting style\n * @param {(string|object)} key - style prop name or {prop: value} pair object\n * @param {string} [value] - style value\n * @name css\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function css(element, key, value) {\n    const style = element.style;\n\n    if (util.isString(key)) {\n        style[key] = value;\n\n        return;\n    }\n\n    util.forEach(key, function(v, k) {\n        style[k] = v;\n    });\n}\n\n/**\n * Get HTML element's design classes.\n * @param {(HTMLElement|SVGElement)} element target element\n * @returns {string} element css class name\n * @name getClass\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function getClass(element) {\n    if (!element || !element.className) {\n        return '';\n    }\n\n    if (util.isUndefined(element.className.baseVal)) {\n        return element.className;\n    }\n\n    return element.className.baseVal;\n}\n\n/**\n * Check element has specific css class\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {string} cssClass - css class\n * @returns {boolean}\n * @name hasClass\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function hasClass(element, cssClass) {\n    if (element.classList) {\n        return element.classList.contains(cssClass);\n    }\n\n    let origin = getClass(element).split(/\\s+/);\n\n    return util.inArray(cssClass, origin) > -1;\n}\n\n/**\n * Set className value\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {(string|string[])} cssClass - class names\n */\nfunction setClassName(element, cssClass) {\n    cssClass = util.isArray(cssClass) ? cssClass.join(' ') : cssClass;\n\n    cssClass = trim(cssClass);\n\n    if (util.isUndefined(element.className.baseVal)) {\n        element.className = cssClass;\n        return;\n    }\n\n    element.className.baseVal = cssClass;\n}\n\n/**\n * Add css class to element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to add\n * @name addClass\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function addClass(element) {    // eslint-disable-line\n    let cssClass = aps.call(arguments, 1);\n\n    if (element.classList) {\n        const classList = element.classList;\n        util.forEach(cssClass, name => {\n            classList.add(name);\n        });\n        return;\n    }\n\n    const origin = getClass(element);\n\n    if (origin) {\n        cssClass = [].concat(origin.split(/\\s+/), cssClass);\n    }\n\n    const newClass = [];\n\n    util.forEach(cssClass, cls => {\n        if (util.inArray(cls, newClass) &lt; 0) {\n            newClass.push(cls);\n        }\n    });\n\n    setClassName(element, newClass);\n}\n\n/**\n * Toggle css class\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to toggle\n * @name toggleClass\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function toggleClass(element) {\n    let cssClass = aps.call(arguments, 1);\n\n    if (element.classList) {\n        util.forEach(cssClass, name => {\n            element.classList.toggle(name);\n        });\n        return;\n    }\n\n    const newClass = getClass(element).split(/\\s+/);\n\n    util.forEach(cssClass, name => {\n        const idx = util.inArray(name, newClass);\n\n        if (idx > -1) {\n            newClass.splice(idx, 1);\n        } else {\n            newClass.push(name);\n        }\n    });\n\n    setClassName(element, newClass);\n}\n\n/**\n * Remove css class from element\n * @param {(HTMLElement|SVGElement)} element - target element\n * @param {...string} cssClass - css classes to remove\n * @name removeClass\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function removeClass(element) {    // eslint-disable-line\n    let cssClass = aps.call(arguments, 1);\n\n    if (element.classList) {\n        const classList = element.classList;\n        util.forEach(cssClass, name => {\n            classList.remove(name);\n        });\n\n        return;\n    }\n\n    const origin = getClass(element).split(/\\s+/);\n\n    const newClass = util.filter(origin, name => {\n        return util.inArray(name, cssClass) &lt; 0;\n    });\n\n    setClassName(element, newClass);\n}\n\n/**\n * getBoundingClientRect polyfill\n * @param {HTMLElement} element - target element\n * @returns {object} rect object\n * @name getRect\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function getRect(element) {\n    let {top, right, bottom, left, width, height} =\n        element.getBoundingClientRect();\n\n    if (util.isUndefined(width) || util.isUndefined(height)) {\n        width = element.offsetWidth;\n        height = element.offsetHeight;\n    }\n\n    return {top, right, bottom, left, width, height};\n}\n\n/**\n * Convert uppercase letter to hyphen lowercase character\n * @param {string} match - match from String.prototype.replace method\n * @returns {string}\n * @name upperToHyphenLower\n * @memberof tui.dom\n * @function\n * @api\n */\nfunction upperToHyphenLower(match) {\n    return '-' + match.toLowerCase();\n}\n\n/**\n * Set data attribute to target element\n * @param {HTMLElement} element - element to set data attribute\n * @param {string} key - key\n * @param {string} value - value\n * @name setData\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function setData(element, key, value) {\n    if (element.dataset) {\n        element.dataset[key] = value;\n\n        return;\n    }\n\n    key = key.replace(/([A-Z])/g, upperToHyphenLower);\n\n    element.setAttribute('data-' + key, value);\n}\n\n/**\n * Get data value from data-attribute\n * @param {HTMLElement} element - target element\n * @param {string} key - key\n * @returns {string} value\n * @name getData\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function getData(element, key) {\n    if (element.dataset) {\n        return element.dataset[key];\n    }\n\n    key = key.replace(/([A-Z])/g, upperToHyphenLower);\n\n    return element.getAttribute('data-' + key);\n}\n\n/**\n * Remove data property\n * @param {HTMLElement} element - target element\n * @param {string} key - key\n * @name removeData\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function removeData(element, key) {\n    if (element.dataset) {\n        delete element.dataset[key];\n\n        return;\n    }\n\n    key = key.replace(/([A-Z])/g, upperToHyphenLower);\n\n    element.removeAttribute('data-' + key);\n}\n\n/**\n * Remove element from parent node.\n * @param {HTMLElement} element - element to remove.\n * @name removeElement\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function removeElement(element) {\n    if (element &amp;&amp; element.parentNode) {\n        element.parentNode.removeChild(element);\n    }\n}\n\n/**\n * Set element bound\n * @param {HTMLElement} element - element to change bound\n * @param {object} bound - bound object\n * @param {number} [bound.top] - top pixel\n * @param {number} [bound.right] - right pixel\n * @param {number} [bound.bottom] - bottom pixel\n * @param {number} [bound.left] - left pixel\n * @param {number} [bound.width] - width pixel\n * @param {number} [bound.height] - height pixel\n * @name setBound\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function setBound(element, {top, right, bottom, left, width, height} = {}) {\n    const args = {top, right, bottom, left, width, height};\n    const newBound = {};\n\n    util.forEach(args, (value, prop) => {\n        if (util.isExisty(value)) {\n            newBound[prop] = util.isNumber(value) ? (value + 'px') : value;\n        }\n    });\n\n    util.extend(element.style, newBound);\n}\n\nconst elProto = Element.prototype;\nconst matchSelector = elProto.matches ||\n    elProto.webkitMatchesSelector ||\n    elProto.mozMatchesSelector ||\n    elProto.msMatchesSelector ||\n    function(selector) {\n        const doc = this.document || this.ownerDocument;\n        return util.inArray(this, findAll(doc, selector)) > -1;\n    };\n\n/**\n * Check element match selector\n * @param {HTMLElement} element - element to check\n * @param {string} selector - selector to check\n * @returns {boolean} is selector matched to element?\n * @name matches\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function matches(element, selector) {\n    return matchSelector.call(element, selector);\n}\n\n/**\n * Find parent element recursively\n * @param {HTMLElement} element - base element to start find\n * @param {string} selector - selector string for find\n * @returns {HTMLElement} - element finded or null\n * @name closest\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function closest(element, selector) {\n    var parent = element.parentNode;\n\n    if (matches(element, selector)) {\n        return element;\n    }\n\n    while (parent &amp;&amp; parent !== document) {\n        if (matches(parent, selector)) {\n            return parent;\n        }\n\n        parent = parent.parentNode;\n    }\n\n\n    return null;\n}\n\n/**\n * Find single element\n * @param {(HTMLElement|string)} [element=document] - base element to find\n * @param {string} [selector] - css selector\n * @returns {HTMLElement}\n * @name find\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function find(element, selector) {\n    if (util.isString(element)) {\n        return document.querySelector(element);\n    }\n\n    return element.querySelector(selector);\n}\n\n/**\n * Find multiple element\n * @param {(HTMLElement|string)} [element=document] - base element to\n *  find\n * @param {string} [selector] - css selector\n * @returns {HTMLElement[]}\n * @name findAll\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function findAll(element, selector) {\n    if (util.isString(element)) {\n        return util.toArray(document.querySelectorAll(element));\n    }\n\n    return util.toArray(element.querySelectorAll(selector));\n}\n\n/**\n * Stop event propagation.\n * @param {Event} e - event object\n * @name stopPropagation\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function stopPropagation(e) {\n    if (e.stopPropagation) {\n        e.stopPropagation();\n\n        return;\n    }\n\n    e.cancelBubble = true;\n}\n\n/**\n * Prevent default action\n * @param {Event} e - event object\n * @name preventDefault\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function preventDefault(e) {\n    if (e.preventDefault) {\n        e.preventDefault();\n\n        return;\n    }\n\n    e.returnValue = false;\n}\n\n/**\n * Check specific CSS style is available.\n * @param {array} props property name to testing\n * @returns {(string|boolean)} return true when property is available\n * @name testCSSProp\n * @memberof tui.dom\n * @function\n * @api\n * @example\n * var props = ['transform', '-webkit-transform'];\n * domutil.testCSSProp(props);    // 'transform'\n */\nfunction testCSSProp(props) {\n    var style = document.documentElement.style,\n        i = 0,\n        len = props.length;\n\n    for (; i &lt; len; i += 1) {\n        if (props[i] in style) {\n            return props[i];\n        }\n    }\n\n    return false;\n}\n\nlet prevSelectStyle = '';\nconst SUPPORT_SELECTSTART = 'onselectstart' in document;\nconst userSelectProperty = testCSSProp([\n    'userSelect',\n    'WebkitUserSelect',\n    'OUserSelect',\n    'MozUserSelect',\n    'msUserSelect'\n]);\n\n/**\n * Disable browser's text selection behaviors.\n * @param {HTMLElement} [el] - target element. if not supplied, use `document`\n * @name disableTextSelection\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function disableTextSelection(el = document) {\n    var style;\n\n    if (SUPPORT_SELECTSTART) {\n        domevent.on(el, 'selectstart', preventDefault);\n    } else {\n        el = (el === document) ? document.documentElement : el;\n        style = el.style;\n        prevSelectStyle = style[userSelectProperty];\n        style[userSelectProperty] = 'none';\n    }\n}\n\n/**\n * Enable browser's text selection behaviors.\n * @param {HTMLElement} [el] - target element. if not supplied, use `document`\n * @name enableTextSelection\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function enableTextSelection(el = document) {\n    if (SUPPORT_SELECTSTART) {\n        domevent.off(el, 'selectstart', preventDefault);\n    } else {\n        el = (el === document) ? document.documentElement : el;\n        el.style[userSelectProperty] = prevSelectStyle;\n    }\n}\n\n/**\n * Represents the text content of a node and its descendants\n * @param {HTMLElement} element - html element\n * @returns {string} text content\n * @name textContent\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function textContent(element) {\n    if (util.isExisty(element.textContent)) {\n        return element.textContent;\n    }\n\n    return element.innerText;\n}\n\n/**\n * Insert element to next of target element\n * @param {HTMLElement} element - html element to insert\n * @param {HTMLElement} target - target element\n * @name insertAfter\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function insertAfter(element, target) {\n    const parent = target.parentNode;\n\n    if (target === parent.lastChild) {\n        parent.appendChild(element);\n    } else {\n        parent.insertBefore(element, target.nextSibling);\n    }\n}\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"