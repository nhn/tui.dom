tui.util.defineNamespace("fedoc.content", {});
fedoc.content["domevent.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * DOM event utility module.\n * @fileoverview Module for handle DOM events\n * @author NHN Ent. FE Development Team &lt;dl_javascript@nhnent.com>\n */\nimport util from 'code-snippet';\nimport {getRect} from './domutil';\n\nconst EVENT_KEY = '_feEventKey';\n\n/**\n * Get event collection for specific HTML element\n * @param {HTMLElement} element - HTML element\n * @param {string} [type] - event type\n * @returns {(object|Map)}\n */\nfunction safeEvent(element, type) {\n    let events = element[EVENT_KEY];\n\n    if (!events) {\n        events = element[EVENT_KEY] = {};\n    }\n\n    if (type) {\n        let handlerMap = events[type];\n\n        if (!handlerMap) {\n            handlerMap = events[type] = new util.Map();\n        }\n\n        events = handlerMap;\n    }\n\n    return events;\n}\n\n/**\n * Memorize DOM event handler for unbinding\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} keyFn - handler function that user passed at on() use\n * @param {function} valueFn - handler function that wrapped by domevent for\n *  implementing some features\n */\nfunction memorizeHandler(element, type, keyFn, valueFn) {\n    var map = safeEvent(element, type),\n        items = map.get(keyFn);\n\n    if (items) {\n        items.push(valueFn);\n    } else {\n        items = [valueFn];\n        map.set(keyFn, items);\n    }\n}\n\n/**\n * Forget memorized DOM event handlers\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} keyFn - handler function that user passed at on() use\n */\nfunction forgetHandler(element, type, keyFn) {\n    safeEvent(element, type).delete(keyFn);\n}\n\n/**\n * Bind DOM events\n * @param {HTMLElement} element - element to bind events\n * @param {string} type - events name\n * @param {function} handler - handler function or context for handler\n *  method\n * @param {object} [context] context - context for handler method.\n */\nfunction bindEvent(element, type, handler, context) {\n    /**\n     * Event handler\n     * @param {Event} e - event object\n     */\n    function eventHandler(e) {\n        handler.call(context || element, e || window.event);\n    }\n\n    /**\n     * Event handler for normalize mouseenter event\n     * @param {MouseEvent} e - event object\n     */\n    function mouseEnterHandler(e) {\n        e = e || window.event;\n\n        if (checkMouse(element, e)) {\n            eventHandler(e);\n        }\n    }\n\n    if ('addEventListener' in element) {\n        if (type === 'mouseenter' || type === 'mouseleave') {\n            type = (type === 'mouseenter') ? 'mouseover' : 'mouseout';\n            element.addEventListener(type, mouseEnterHandler);\n            memorizeHandler(element, type, handler, mouseEnterHandler);\n        } else {\n            element.addEventListener(type, eventHandler);\n            memorizeHandler(element, type, handler, eventHandler);\n        }\n    } else if ('attachEvent' in element) {\n        element.attachEvent('on' + type, eventHandler);\n        memorizeHandler(element, type, handler, eventHandler);\n    }\n}\n\n/**\n * Unbind DOM events\n * @param {HTMLElement} element - element to unbind events\n * @param {string} type - events name\n * @param {function} handler - handler function or context for handler\n *  method\n */\nfunction unbindEvent(element, type, handler) {\n    const events = safeEvent(element, type);\n    const items = events.get(handler);\n\n    if (!items) {\n        return;\n    }\n\n    forgetHandler(element, type, handler);\n\n    util.forEach(items, func => {\n        if ('removeEventListener' in element) {\n            element.removeEventListener(type, func);\n        } else if ('detachEvent' in element) {\n            element.detachEvent('on' + type, func);\n        }\n    });\n}\n\n\n/**\n * Bind DOM events\n * @param {HTMLElement} element - element to bind events\n * @param {(string|object)} types - Space splitted events names or\n *  eventName:handler object\n * @param {(function|object)} handler - handler function or context for handler\n *  method\n * @param {object} [context] context - context for handler method.\n * @name on\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function on(element, types, handler, context) {\n    if (util.isString(types)) {\n        util.forEach(types.split(/\\s+/g), type => {\n            bindEvent(element, type, handler, context);\n        });\n\n        return;\n    }\n\n    util.forEach(types, (func, type) => {\n        bindEvent(element, type, func, handler);\n    });\n}\n\n/**\n * Bind DOM event. this event will unbind after invokes.\n * @param {HTMLElement} element - HTMLElement to bind events.\n * @param {(string|object)} types - Space splitted events names or\n *  eventName:handler object.\n * @param {*} handler - handler function or context for handler method.\n * @param {*} [context] - context object for handler method.\n * @name once\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function once(element, types, handler, context) {\n    if (util.isObject(types)) {\n        for (let [fn, type] of types) {\n            once(element, type, fn, handler);\n        }\n\n        return;\n    }\n\n    const onceHandler = (...args) => {\n        handler.apply(context || element, args);\n        off(element, types, onceHandler, context);\n    };\n\n    on(element, types, onceHandler, context);\n}\n\n/**\n * Unbind DOM events\n * @param {HTMLElement} element - element to unbindbind events\n * @param {(string|object)} types - Space splitted events names or\n *  eventName:handler object\n * @param {(function|object)} handler - handler function or context for handler\n *  method\n * @name off\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function off(element, types, handler) {\n    if (util.isString(types)) {\n        util.forEach(types.split(/\\s+/g), type => {\n            unbindEvent(element, type, handler);\n        });\n\n        return;\n    }\n\n    util.forEach(types, (func, type) => {\n        unbindEvent(element, type, func);\n    });\n}\n\n/**\n * Check mouse was leave event element with ignoreing child nodes\n * @param {HTMLElement} element - element to check\n * @param {MouseEvent} e - mouse event\n * @returns {boolean} whether mouse leave element?\n * @name checkMouse\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function checkMouse(element, e) {\n    var related = e.relatedTarget;\n\n    if (!related) {\n        return true;\n    }\n\n    try {\n        while (related &amp;&amp; (related !== element)) {\n            related = related.parentNode;\n        }\n    } catch (err) {\n        return false;\n    }\n\n    return (related !== element);\n}\n\n/**\n * Normalize mouse event's button attributes.\n *\n * Can detect which button is clicked by this method.\n *\n * Meaning of return numbers\n *\n * - 0: primary mouse button\n * - 1: wheel button or center button\n * - 2: secondary mouse button\n * @param {MouseEvent} mouseEvent - The mouse event object want to know.\n * @returns {number} - The value of meaning which button is clicked?\n * @name getMouseButton\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function getMouseButton(mouseEvent) {\n    const primary = '0,1,3,5,7';\n    const secondary = '2,6';\n    const wheel = '4';\n\n    if (document.implementation.hasFeature('MouseEvents', '2.0')) {\n        return mouseEvent.button;\n    }\n\n    let button = String(mouseEvent.button);\n    if (util.inArray(button, primary) > -1) {\n        return 0;\n    } else if (util.inArray(button, secondary) > -1) {\n        return 2;\n    } else if (util.inArray(button, wheel) > -1) {\n        return 1;\n    }\n\n    return null;\n}\n\n/**\n * Get mouse position from mouse event\n *\n * If supplied relatveElement parameter then return relative position based on\n *  element\n * @param {(MouseEvent|object|number[])} position - mouse position object\n * @param {HTMLElement} relativeElement HTML element that calculate relative\n *  position\n * @returns {number[]} mouse position\n * @name getMousePosition\n * @memberof tui.dom\n * @function\n * @api\n */\nexport function getMousePosition(position, relativeElement) {\n    let rect, clientX, clientY;\n\n    if (util.isArray(position)) {\n        clientX = position[0];\n        clientY = position[1];\n    } else {\n        clientX = position.clientX;\n        clientY = position.clientY;\n    }\n\n    if (!relativeElement) {\n        return [clientX, clientY];\n    }\n\n    rect = getRect(relativeElement);\n\n    return [\n        clientX - rect.left - relativeElement.clientLeft,\n        clientY - rect.top - relativeElement.clientTop\n    ];\n}\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"